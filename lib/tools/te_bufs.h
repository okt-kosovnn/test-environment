/* SPDX-License-Identifier: Apache-2.0 */
/** @file
 * @brief API to deal with buffers
 *
 * @defgroup te_tools_te_bufs Regular binary buffers
 * @ingroup te_tools
 * @{
 *
 * Allocation of buffers, fill in by random numbers, etc.
 *
 *
 * Copyright (C) 2004-2022 OKTET Labs Ltd. All rights reserved.
 */

#ifndef __TE_TOOLS_BUFS_H__
#define __TE_TOOLS_BUFS_H__

#include "te_config.h"

#include <stdlib.h>

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif

#include "te_defs.h"
#include "te_errno.h"
#include "te_alloc.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Compiled buffer fill pattern.
 *
 * The structure should be treated as opaque and
 * only filled by te_compile_buf_pattern().
 *
 * The compiled pattern is a sequence of "possible bytes",
 * where each "possible byte" is a number followed by
 * that many byte values. If the number is zero, any byte
 * is possible at that position.
 */
typedef struct te_buf_pattern {
    /** Start of the pattern bytes. */
    uint8_t *start;
    /** End of the pattern bytes. */
    uint8_t *end;
    /** Repeating part of the pattern bytes. */
    uint8_t *repeat;
    /** Suffix part of the pattern bytes. */
    uint8_t *suffix;
    /** Number of bytes generated by @a suffix. */
    size_t suffix_len;
} te_buf_pattern;

/**
 * Convert a textual pattern spec into a compiled pattern.
 *
 * The pattern spec is a string consisting of three parts:
 * @e prefix @c ( @e repeat @c ) @e suffix,
 * where both @e prefix and @e suffix are optional.
 *
 * The resulting byte sequence is produced as follows:
 * - first @e prefix is generated;
 * - then @e repeat is repeated until there is only room for @e suffix
 * - then @e suffix is generated.
 *
 * If the buffer is shorter than the prefix and the suffix together, the suffix
 * is laid over the prefix. This is slightly counter-intuitive, but it e.g.
 * allows to ensure easily that a string would be zero-terminated.
 *
 * Each part is a sequence of byte specs, which are either:
 * - any verbatim bytes except an open bracket, a backtick and a binary zero;
 * - a backtick followed by any byte including a binary zero;
 * - a byte set.
 *
 * A byte set is a sequence of elements enclosed in `[ ... ]`,
 * where each element is either:
 * - any verbatim byte except a hyphen, a caret, a closing bracket,
 *   a backtick and a binary zero;
 * - a backtick followed by any byte including a binary zero;
 * - a range: a pair of bytes separated by @c -;
 * - a literal unescaped hyphen if it's the first or the last element
 *   of a byte set.
 *
 * An empty byte set `[]` means any byte.
 *
 * A byte set may also contain a right-associative exclusion operator @c ^:
 * @e A @c ^ @e B @c ^ @e C means "all bytes from @e A except (those in @e B
 * except those in @e C); see below for examples.
 *
 * @note The backtick was chosen as an escape character instead of a more
 *       common backslash in order to avoid double-escaping in C literals.
 *
 * The compiled pattern is a sequence of "possible bytes",
 * where each "possible byte" is a number followed by
 * that many byte values. If the number is zero, any byte
 * is possible at that position.
 *
 * The compiled pattern data are stored in
 * @p storage which should be an array of at least @p max_size bytes.
 * @p pattern holds pointers inside @p storage, so the latter should not
 * have a shorter duration that the former.
 *
 * @par Examples:
 *
 * - @c "[0-9]"                        a sequence of decimal digits
 *                                     (not zero-terminated)
 * - @c "[a-zA-Z_]([a-zA-Z0-9_])`\0"   a valid C identifier
 *                                     (zero-terminated)
 * - @c "[^`\0\x1-\x1F\x7F-\xFF^\n\t]" a sequence of printable ASCII
 *                                     characters  + newline and tab
 * - @c "[ -~\n\t]"                    a shorter version of the previous
 * - @c "`[([0-9a-f])`]`\0"            a zero-terminated sequence of
 *                                     hexadecimal digits enclosed in brackets
 *
 * @param[in]  spec      pattern spec
 * @param[out] storage   buffer to hold the compiled pattern
 * @param[in]  max_size  total size of @p storage
 * @param[out] pattern   compiled pattern header
 *                       (the structure is completely initialised by
 *                        this function)
 * @return status code
 * @retval TE_ENOBUFS  There is not enough room in @p storage to hold the data.
 * @retval TE_EILSEQ   An unmatched @c [ or @c ( is found.
 * @retval TE_ENODATA  The spec contains no actual byte specs.
 * @retval TE_EINVAL   The spec contains multiple repeat sections.
 */
extern te_errno te_compile_buf_pattern(const char *spec,
                                       uint8_t *storage,
                                       size_t max_size,
                                       te_buf_pattern *pattern);

/**
 * Fill @p buf of length @p len with random bytes according
 * to a given @p pattern.
 *
 * If @p pattern is @c NULL, the buffer is filled with unconstrained
 * random bytes.
 *
 * @param[out] buf      buffer
 * @param[in]  len      length of @p buf
 * @param[in]  pattern  compiled pattern (see te_compile_buf_pattern())
 */
extern void te_fill_pattern_buf(void *buf, size_t len,
                                const te_buf_pattern *pattern);

/**
 * Allocate a buffer of random size between @p min and @p max
 * filled with random bytes according to @p pattern.
 *
 * If @p pattern is @c NULL, the buffer is filled with unconstrained
 * random bytes.
 *
 * @param[in]  min      minimum allowed size
 * @param[in]  max      maximum allowed size
 * @param[out] p_len    actual size of the buffer (may be @c NULL)
 * @param[in]  pattern  compiled pattern (see te_compile_buf_pattern())
 *
 * @return an allocated and filled buffer (never @c NULL)
 *
 * @note @p p_len may be @c NULL, if either @p min is equal to @p max,
 *       or @p spec contains a terminating @c NUL byte, since in this
 *       case the size may be determined by @c strlen().
 */
extern void *te_make_pattern_buf(size_t min, size_t max,
                                 size_t *p_len, const te_buf_pattern *pattern);

/**
 * Fill @p buf of length @p len with random bytes according
 * to a given @p spec.
 *
 * @param[out] buf      buffer
 * @param[in]  len      length of @p buf
 * @param[in]  spec     pattern spec (see te_compile_buf_pattern())
 *
 * @return status code
 *
 * @note The function only returns an error if @p spec is malformed.
 *       So callers that always pass known constant patterns to it,
 *       need not check for the return value.
 */
extern te_errno te_fill_spec_buf(void *buf, size_t len, const char *spec);

/**
 * Allocate a buffer of random size between @p min and @p max
 * filled with random bytes according to @p spec.
 *
 * @param[in]  min      minimum allowed size
 * @param[in]  max      maximum allowed size
 * @param[out] p_len    actual size of the buffer (may be @c NULL)
 * @param[in]  spec     pattern spec (see te_compile_buf_pattern())
 *
 * @return an allocated and filled buffer
 *
 * @note @p p_len may be @c NULL, if either @p min is equal to @p max,
 *       or @p spec contains a terminating @c NUL byte, since in this
 *       case the size may be determined by @c strlen().
 *
 * @note The function only returns @c NULL if @p spec is malformed.
 *       So callers that always pass known constant patterns to it,
 *       need not check for the return value being not @c NULL.
 */
extern void *te_make_spec_buf(size_t min, size_t max, size_t *p_len,
                              const char *spec);

/** Common fill patterns specs.
 *
 * All sequences except TE_FILL_SPEC_BINARY are zero-terminated.
 *@{
 */

/** A sequence of decimal digits. */
#define TE_FILL_SPEC_DECIMAL "([0-9])`\0"

/** A sequence of hex digits. */
#define TE_FILL_SPEC_HEX "([0-9A-F])`\0"

/** A sequence of hex digits (lowercase variant). */
#define TE_FILL_SPEC_HEX_LCASE "([0-9a-f])`\0"

/** A sequence of Latin letters. */
#define TE_FILL_SPEC_WORD "([a-zA-Z])`\0"

/** A valid C identifier. */
#define TE_FILL_SPEC_C_ID "[a-zA-Z_]([0-9a-zA-Z_])`\0"

/**
 * A safe filename.
 *
 * A name contains no directory separators,
 * no wildcards, no spaces and no characters
 * that may be interpreted by a shell, such as
 * a dollar sign. A name also does not start
 * with a dot.
 */
#define TE_FILL_SPEC_FILENAME "[0-9a-zA-Z_%+=@`^-]([0-9a-zA-Z_.%+=@`^-])`\0"

/**
 * A valid URI chunk.
 *
 * It contains only RFC 3986 "unreserved" characters:
 * alphanumerics, underscores, hyphens, periods and tildes.
 */
#define TE_FILL_SPEC_URI_CHUNK "([0-9a-zA-Z_.~-])`\0"
/**
 * A valid XML name.
 *
 * It contains only alphanumerics, underscores, hyphens
 * and periods, and it starts with either an alphanumeric
 * or an underscore.
 */
#define TE_FILL_SPEC_XML_NAME "[a-zA-Z_]([0-9a-zA-Z_.-])`\0"

/**
 * A valid XML text.
 *
 * It contains any printable characters except quotes,
 * apostrophes, ampersands and angle brackets. It may
 * contain newlines.
 */
#define TE_FILL_SPEC_XML_TEXT "([\n -~^\"'&<>])`\0"

/**
 * A valid content of a JSON string literal.
 *
 * It contains any printable characters except quotes and
 * backslashes.
 */
#define TE_FILL_SPEC_JSON_STR "([ -~^\\\"])`\0"

/** A sequence of printable characters. */
#define TE_FILL_SPEC_PRINTABLE "([ -~])`\0"

/** A sequence of printable characters, tabs and newlines. */
#define TE_FILL_SPEC_TEXT "([\n\t -~])`\0"

/** A random sequence of ASCII characters excluding @c NUL. */
#define TE_FILL_SPEC_ASCII "([\x1-\x7F])`\0"

/** A random sequence of bytes including @c NULs. */
#define TE_FILL_SPEC_BINARY "[]"
/**@}*/

/**
 * Fill buffer with random bytes.
 *
 * @param[out] buf      buffer pointer
 * @param[in]  len      buffer length
 *
 * @sa te_fill_pattern_buf()
 */
static inline void
te_fill_buf(void *buf, size_t len)
{
    te_fill_pattern_buf(buf, len, NULL);
}

/**
 * Allocate buffer of random size between @p min and @p max and fill
 * it with random bytes.
 *
 * @param[in]  min     minimum allowed size
 * @param[in]  max     maximum allowed size
 * @param[out] p_len   actual size of the buffer
 *                     (may be @c NULL if @p min is equal to @p max)
 *
 * @return an allocated and filled buffer
 *
 * @sa te_make_pattern_buf()
 */
static inline void *
te_make_buf(size_t min, size_t max, size_t *p_len)
{
    return te_make_pattern_buf(min, max, p_len, NULL);
}

/**
 * Allocate a buffer of given size @p len and fill it with
 * random bytes.
 *
 * @param len    buffer length
 *
 * @return an allocated and filled buffer
 *
 * @sa te_make_pattern_buf()
 */
static inline void *
te_make_buf_by_len(size_t len)
{
    return te_make_buf(len, len, NULL);
}

/**
 * Allocate a buffer of at least @p min bytes and fill it with
 * random bytes
 *
 * @param[in]  min       minimum buffer length
 * @param[out] p_len     actual buffer length
 *
 * @return an allocated and filled buffer
 */
static inline void *
te_make_buf_min(size_t min, size_t *p_len)
{
    return te_make_buf(min, min + 10, p_len);
}

/**
 * Fill a buffer with random printable characters.
 *
 * The last byte will be zero, so the result may be
 * used as a C string.
 *
 * @param[out] buf     buffer pointer
 * @param[in] len      buffer length
 *
 * @sa te_fill_spec_buf()
 */
static inline void
te_fill_printable_buf(void *buf, size_t len)
{
    te_fill_spec_buf(buf, len, TE_FILL_SPEC_PRINTABLE);
}

/**
 * Allocate buffer of random size between @p min and @p max and fill
 * it with random printable characters. The buffer will be NUL-terminated,
 * so it can be used as a C string.
 *
 * @param[in]  min     minimum allowed size
 * @param[in]  max     maximum allowed size
 * @param[out] p_len   actual size of the buffer
 *                     (may be @c NULL)
 *
 * @return an allocated and filled buffer
 *
 * @sa te_make_spec_buf()
 */
static inline char *
te_make_printable_buf(size_t min, size_t max, size_t *p_len)
{
    return te_make_spec_buf(min, max, p_len, TE_FILL_SPEC_PRINTABLE);
}

/**
 * Allocate a buffer of given size @p len and fill it with
 * random printable characters. The buffer will be NUL-terminated.
 *
 * @param len    buffer length
 *
 * @return an allocated and filled buffer
 *
 * @sa te_make_spec_buf()
 */
static inline char *
te_make_printable_buf_by_len(size_t len)
{
    return te_make_printable_buf(len, len, NULL);
}

/**
 * Allocate memory and fill it with the @p byte
 *
 * @param num   Items number
 * @param size  Item instance size
 * @param byte  Byte to fill memory
 *
 * @return Pointer to the memory block
 */
extern void *te_calloc_fill(size_t num, size_t size, int byte);

/**
 * Like te_compare_bufs(), but the difference log will be shown as if
 * the data start at @p log_offset.
 *
 * @note The value of @p log_offset does not in any way affect
 *       the comparison itself --- it only modifies how offsets
 *       are printed, so if @p log_level is zero, the function
 *       behaves exactly as te_compare_bufs(), irrespective of
 *       @p log_offset.
 *
 * @param exp_buf     Expected data.
 * @param exp_len     Length of expected data.
 * @param n_copies    Number of copies of the expected
 *                    buffer that should be in the actual data.
 * @param actual_buf  Actual data.
 * @param actual_len  Length of actual data.
 * @param log_level   Log level for diff dumps.
 *                    If zero, no logging is done.
 * @param log_offset  The virtual offset for logging.
 *
 * @return @c true if the lengths and the content of buffers are the same.
 */
extern bool te_compare_bufs_at(const void *exp_buf, size_t exp_len,
                               unsigned int n_copies,
                               const void *actual_buf, size_t actual_len,
                               unsigned int log_level,
                               size_t log_offset);

/**
 * Compare and probably log the difference of two buffers.
 *
 * It can compare buffers of unequal size.
 *
 * @note Unlike CHECK_BUFS_EQUAL(), it does not fail a test,
 *       so it can be used both in the Engine and agents.
 *
 * @param exp_buf     Expected data.
 * @param exp_len     Length of expected data.
 * @param n_copies    Number of copies of the expected
 *                    buffer that should be in the actual data.
 * @param actual_buf  Actual data.
 * @param actual_len  Length of actual data.
 * @param log_level   Log level for diff dumps.
 *                    If zero, no logging is done.
 *
 * @return @c true if the lengths and the content of buffers are the same.
 */
static inline bool
te_compare_bufs(const void *exp_buf, size_t exp_len,
                unsigned int n_copies,
                const void *actual_buf, size_t actual_len,
                unsigned int log_level)
{
    return te_compare_bufs_at(exp_buf, exp_len, n_copies,
                              actual_buf, actual_len,
                              log_level, 0);
}

#ifdef HAVE_SYS_UIO_H

/**
 * Compare and probably log the difference of two iovecs.
 *
 * The number and layout of iovecs is completely arbitrary,
 * i.e. the expected and the actual series may have different
 * lengths and the data may be scattered across iovec differently.
 *
 * In some of the expected iovecs the data pointer @c iov_base may be
 * @c NULL, in which case matching actual data must be zeroes.
 *
 * @param n_exp       Number of expected iovecs.
 * @param exp         The array of expected iovecs.
 * @param n_actual    Number of actual iovecs.
 * @param actual      The array of actual iovecs.
 * @param log_level   Log level for diff dumps.
 *                    If zero, no logging is done.
 *
 * @return @c true if the total contents of iovec series are the same.
 */
extern bool te_compare_iovecs(size_t n_exp, const struct iovec exp[n_exp],
                              size_t n_actual,
                              const struct iovec actual[n_actual],
                              unsigned int log_level);

#endif /* HAVE_SYS_UIO_H */

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* !__TE_TOOLS_BUFS_H__ */
/**@} <!-- END te_tools_te_bufs --> */
